//
// Copyright (C) 2019 Dmitry Kolesnikov
//
// This file may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
// https://github.com/fogfish/golem
//

// Golem is a tool to generate generic type wrappers around given type T.
//
// Typically this tool is executed by `go generate`, like this:
//
//   //go:generate golem -type Foo -generic github.com/fogfish/golem/stream/stream.go
//
// The command takes few arguments:
//
//   -type string   defines a parametrization type of generic algorithm.
//
//   -generic path  locates a path to generic algorithm.
//
// The command creates a file generic_type.go in same directory containing a final
// definition of generic program. Generics takes a type parameter using type aliases.
//
//   type TYPE interface{}
//
//   func (t TYPE) This() { ... }
//
// The unsafe interface{} declaration is replaced with a specied type. The utility replaces
// each appearance of TYPE token with given value.
//
//   type StreamFoo Foo
//
//   func (t StreamFoo) This() { ... }
//
// Install
//
//   go get -u github.com/fogfish/golem/cmd/golem
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"io/ioutil"
	"log"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

//
type opts struct {
	kind    *string
	generic *string
	native  *bool
}

func parseOpts() opts {
	spec := opts{
		flag.String("type", "", "defines a parametrization type of generic algorithm."),
		flag.String("generic", "", "locates a path to generic algorithm."),
		flag.Bool("native", false, "skip prefix declaration for native types"),
	}
	flag.Parse()
	return spec
}

//
func declareType(file []byte, kind string) []byte {
	return bytes.Replace(file,
		[]byte("type TYPE interface{}"),
		[]byte("type TYPE "+kind),
		1,
	)
}

//
func referenceType(file []byte, kind string) []byte {
	return bytes.ReplaceAll(file,
		[]byte("TYPE"),
		[]byte(kind),
	)
}

//
func repackage(file []byte, pkg string) []byte {
	re := regexp.MustCompile(`package (.*)\n`)
	return re.ReplaceAll(file, []byte("package "+pkg+"\n"))
}

//
func main() {
	var err error
	log.SetFlags(0)
	log.SetPrefix("==> golem: ")
	opt := parseOpts()

	pkg, err := build.Default.ImportDir(".", 0)
	if err != nil {
		log.Fatal(err)
	}

	source := filepath.Join(build.Default.GOPATH, "src", *opt.generic)
	generic := strings.TrimSuffix(filepath.Base(source), filepath.Ext(source))

	filename := fmt.Sprintf("%s_%s.go", generic, strings.ToLower(*opt.kind))
	typename := strings.Title(generic) + strings.Title(*opt.kind)
	if *opt.native {
		filename = fmt.Sprintf("%s.go", *opt.kind)
		typename = strings.Title(*opt.kind)
	}

	input, err := ioutil.ReadFile(source)
	if err != nil {
		log.Fatal(err)
	}

	a := declareType(input, *opt.kind)
	b := referenceType(a, typename)
	c := repackage(b, pkg.Name)

	output := bytes.NewBuffer([]byte{})
	output.Write([]byte("// Code generated by `golem` package\n"))
	output.Write([]byte(fmt.Sprintf("// Source: %s\n", *opt.generic)))
	output.Write([]byte(fmt.Sprintf("// Time: %s\n\n", time.Now().UTC())))

	output.Write(c)

	ioutil.WriteFile(filepath.Join(pkg.PkgRoot, filename), output.Bytes(), 0777)
	log.Printf("%s.%s", generic, typename)
}
