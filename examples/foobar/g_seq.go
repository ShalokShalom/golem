//
// Code generated by `golem` package
// Source: github.com/fogfish/golem/seq/seq.go
// Time: 2020-04-10 11:23:26.021841 +0000 UTC
//
//
// Copyright (C) 2019 Dmitry Kolesnikov
//
// This file may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
// https://github.com/fogfish/golem
//

package foobar

import (
	
)

// AnyT is Seq data type build of `generic.T` elements.
// It is a type alias of `[]generic.T`
type Seq []FooBar

// Contain tests if sequence contains an element
func (seq Seq) Contain(e FooBar,) bool {
	return seq.Exists(func(x FooBar,) bool { return x == e })
}

// ContainSlice tests if sequence contains a sub-sequence
// func (seq AnyT) ContainSlice(subseq AnyT) bool

// Count number of elements that satisfy the predicate
func (seq Seq) Count(p func(FooBar,) bool) int {
	c := 0
	for _, x := range seq {
		if p(x) {
			c = c + 1
		}
	}
	return c
}

// Diff computes the difference between sequences: seq -- that
// func (seq AnyT) Diff(that AnyT) AnyT

// Distinct builds a new sequence without any duplicate elements
func (seq Seq) Distinct() Seq {
	s := Seq{}
	for _, x := range seq {
		if !s.Contain(x) {
			s = append(s, x)
		}
	}
	return s
}

// Drop removes n elements from head of sequence
func (seq Seq) Drop(n int) Seq {
	return append(seq[:0:0], seq[n:]...)
}

// DropWhile removes elements from sequence head while predicate returns true
// and returns remaining sequence suffix.
func (seq Seq) DropWhile(p func(FooBar,) bool) Seq {
	for i, x := range seq {
		if !p(x) {
			return append(seq[:0:0], seq[i:]...)
		}
	}
	return Seq{}
}

// Exists tests if a predicate holds for at least one element
func (seq Seq) Exists(p func(FooBar,) bool) bool {
	for _, x := range seq {
		if p(x) {
			return true
		}
	}
	return false
}

// Filter selects all elements which satisfy predicate
func (seq Seq) Filter(p func(FooBar,) bool) Seq {
	s := Seq{}
	for _, x := range seq {
		if p(x) {
			s = append(s, x)
		}
	}
	return s
}

// Find returns the first element that satisfy predicate
func (seq Seq) Find(p func(FooBar,) bool) (e FooBar,) {
	for _, x := range seq {
		if p(x) {
			return x
		}
	}
	return
}

// ForAll tests where a predicate holds for elements of sequence
func (seq Seq) ForAll(p func(FooBar,) bool) bool {
	if len(seq) == 0 {
		return false
	}
	for _, x := range seq {
		if !p(x) {
			return false
		}
	}
	return true
}

// FMap applies high-order function (clojure) to all elements of sequence
func (seq Seq) FMap(f func(FooBar,)) {
	for _, x := range seq {
		f(x)
	}
}

// Fold applies associative binary operator to sequence
func (seq Seq) Fold(f func(FooBar, FooBar,) FooBar, empty FooBar,) FooBar {
	acc := empty
	for _, x := range seq {
		acc = f(x, acc)
	}
	return acc
}

// GroupBy shards sequence into map of sequences with descriminator function
func (seq Seq) GroupBy(f func(FooBar,) int) map[int]Seq {
	s := make(map[int]Seq)
	for _, x := range seq {
		key := f(x)
		shard, exists := s[key]
		if exists {
			s[key] = append(shard, x)
		} else {
			s[key] = Seq{x}
		}
	}
	return s
}

// Join takes sequence of sequence, flattens and append it
func (seq Seq) Join(subseq Seq) Seq {
	seq = append(seq, subseq...)
	return seq
}

// Intersect computes the intersection of sequences: seq ^ that
// func (seq AnyT) Intersect(that AnyT) AnyT

// Map applies high-order function to all element of sequence.
func (seq Seq) Map(f func(FooBar,) FooBar,) Seq {
	s := Seq{}
	for _, x := range seq {
		s = append(s, f(x))
	}
	return s
}

// Partition split sequence into two sequence accroding to predicate
// It is equivalent of consequent calls to Filter/FilterNot
func (seq Seq) Partition(p func(FooBar,) bool) (Seq, Seq) {
	a := Seq{}
	b := Seq{}
	for _, x := range seq {
		if p(x) {
			a = append(a, x)
		} else {
			b = append(b, x)
		}
	}
	return a, b
}

// Reverse returns a new sequence with elements in reserve order
// func (seq AnyT) Reverse() AnyT

// Span splits the sequences into prefix/suffix pair according to predicate
// It is equivalent of consequent calls to TakeWhile/DropWhile
// func (seq AnyT) Span(p Predicate) AnyT, AnyT

// Split sequence to nested sequence with given splitting predicated
func (seq Seq) Split(p func(FooBar,) bool) []Seq {
	s := make([]Seq, 0)
	i := 0
	for j, x := range seq {
		if p(x) {
			if i != j {
				s = append(s, seq[i:j])
			}
			i = j
		}
	}
	s = append(s, seq[i:])
	return s
}

// Take accepts n elements from head of sequence
func (seq Seq) Take(n int) Seq {
	return append(seq[:0:0], seq[:n]...)
}

// TakeWhile accumulates elements from sequence head while predicate returns true
// and returns this prefix.
func (seq Seq) TakeWhile(p func(FooBar,) bool) Seq {
	for i, x := range seq {
		if !p(x) {
			return append(seq[:0:0], seq[:i]...)
		}
	}
	return append(Seq{}, seq...)
}
